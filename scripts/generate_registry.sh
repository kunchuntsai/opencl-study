#!/bin/bash

# Auto-generate algorithm registry by scanning source files
# Finds all *_ref.c files and creates registration code

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
SRC_DIR="$PROJECT_ROOT/src"
OUTPUT_FILE="$SRC_DIR/utils/auto_registry.c"

echo "=== Auto-generating algorithm registry ==="

# Find all algorithm reference files
ALGO_FILES=$(find "$SRC_DIR" -name "*_ref.c" -type f | sort)

if [ -z "$ALGO_FILES" ]; then
    echo "Error: No algorithm files found (*_ref.c)"
    exit 1
fi

# Start generating the output file
cat > "$OUTPUT_FILE" <<'EOF'
/**
 * @file auto_registry.c
 * @brief Auto-generated algorithm registry
 *
 * This file is automatically generated by scripts/generate_registry.sh
 * DO NOT EDIT MANUALLY - your changes will be overwritten!
 *
 * The build system scans for all *_ref.c files and automatically
 * registers them here.
 */

#include "op_interface.h"
#include "op_registry.h"

EOF

# Add forward declarations for each algorithm
echo "// Forward declarations" >> "$OUTPUT_FILE"
for file in $ALGO_FILES; do
    # Extract algorithm name (e.g., dilate3x3_ref.c -> dilate3x3)
    basename=$(basename "$file" .c)
    algo_name=${basename%_ref}

    echo "Found algorithm: $algo_name"

    # Convert snake_case to PascalCase (e.g., dilate3x3 -> Dilate3x3)
    pascal_name=$(echo "$algo_name" | awk -F'_' '{for(i=1;i<=NF;i++) printf "%s", toupper(substr($i,1,1)) substr($i,2)}')

    # Add extern declarations for standard functions
    cat >> "$OUTPUT_FILE" <<EOF
extern void ${pascal_name}Ref(const OpParams* params);
extern int ${pascal_name}Verify(const OpParams* params, float* max_error);
extern int ${pascal_name}SetKernelArgs(cl_kernel kernel, cl_mem input_buf, cl_mem output_buf, const OpParams* params);
EOF
done

# Add algorithm structures
echo "" >> "$OUTPUT_FILE"
echo "// Algorithm structures" >> "$OUTPUT_FILE"
for file in $ALGO_FILES; do
    basename=$(basename "$file" .c)
    algo_name=${basename%_ref}

    # Convert snake_case to PascalCase (e.g., dilate3x3 -> Dilate3x3)
    pascal_name=$(echo "$algo_name" | awk -F'_' '{for(i=1;i<=NF;i++) printf "%s", toupper(substr($i,1,1)) substr($i,2)}')

    # Extract display name from config file first line
    # Config files start with: "# Dilate 3x3 Algorithm Configuration"
    config_file="$PROJECT_ROOT/config/${algo_name}.ini"
    display_name=""

    if [ -f "$config_file" ]; then
        # Extract first comment line and get the algorithm name part
        first_line=$(head -n1 "$config_file")
        # Remove "# " prefix and " Algorithm Configuration" suffix
        display_name=$(echo "$first_line" | sed 's/^#[[:space:]]*//; s/ Algorithm Configuration$//')
    fi

    # If no display name found in config, generate from algo_name
    if [ -z "$display_name" ]; then
        # Convert snake_case to Title Case with spaces (e.g., dilate3x3 -> Dilate 3x3)
        display_name=$(echo "$algo_name" | sed -E 's/([a-z])([0-9])/\1 \2/g; s/_/ /g' | awk '{for(i=1;i<=NF;i++) $i=toupper(substr($i,1,1)) tolower(substr($i,2))}1')
    fi

    # Generate algorithm structure
    cat >> "$OUTPUT_FILE" <<EOF
static Algorithm ${algo_name}_algorithm = {
    .name = "$display_name",
    .id = "$algo_name",
    .reference_impl = ${pascal_name}Ref,
    .verify_result = ${pascal_name}Verify,
    .set_kernel_args = ${pascal_name}SetKernelArgs
};

EOF
done

# Add registration function
cat >> "$OUTPUT_FILE" <<'EOF'
/**
 * @brief Auto-register all algorithms
 *
 * Called automatically before main() using constructor attribute.
 * Registers all discovered algorithms with the registry.
 */
__attribute__((constructor))
static void auto_register_algorithms(void) {
EOF

for file in $ALGO_FILES; do
    basename=$(basename "$file" .c)
    algo_name=${basename%_ref}

    echo "    RegisterAlgorithm(&${algo_name}_algorithm);" >> "$OUTPUT_FILE"
done

cat >> "$OUTPUT_FILE" <<'EOF'
}
EOF

echo "Generated: $OUTPUT_FILE"
echo "Registered $(echo "$ALGO_FILES" | wc -l | tr -d ' ') algorithms"
