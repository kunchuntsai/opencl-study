## Plan
I'll have two executables
- one for current implementaion (algorithm_runner.c)
- one for a new host implementation (android_runner.c)
- they will share the same config, examples, utils (json parser) and verify
- single CMakeLists with BUILD_ANDROID option for conditional build


## Modules
UI layer: CLI as a entry
- main.c

lib: SDK library (with source provided still)
- I'd like to provide the source when user needs to build by themselves
- user don't need to build the lib most of the time, they just add json and example/c_ref and/or example/cl/

## User Journey
### How does a user add a new algorithm?
- users are suppose add JSON and kernel codes only (c reference is optional), then they don't need to build the project just run it
- we will get: program binary, desktop executable, android executable

### In cl_extension case
Overall workflow
- consume: JSON and cl files (c reference as optional)
- produce: a) generate program binary, b) generate opencl-study executable (desktop), c) desktop processing results, d) android executable
- running (desktop): a) consume program binary then run the opencl-study executable -> desktop processing results
- running (android): a) consume program binary then run the android executable -> android processing results

In each project:
current current (opencl-study)
- consume: JSON and cl files (c reference as optional)
- produce (./run.sh): generate program binary, generate opencl-study executable (desktop), desktop processing results
- running (2nd ./run.sh): consume program binary then run the opencl-study executable (desktop), desktop processing results

android build target (same repo, via `./scripts/build.sh --android`)
- consume: JSON for kernel arguments, program binary generated by opencl-study
- produce: android executable
- running (adb push to android): take program binary and run -> android processing results


### In standard case
Overall workflow
- consume: JSON and cl files (c reference as optional)
- produce: a) generate program binary, b) generate opencl-study executable (desktop), c) desktop processing results
- running (desktop): a) consume program binary then run the opencl-study executable -> desktop processing results

In each project:
current current (opencl-study)
- consume: JSON and cl files (c reference as optional)
- produce (./run.sh): program binary, opencl-study executable (desktop), desktop processing results
- running (2nd ./run.sh): take program binary and run the processing results

(no android-runner)


## Project Structure
```
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ inputs.json                 # Global input image definitions
â”‚   â”œâ”€â”€ outputs.json                # Global output image definitions
â”‚   â”œâ”€â”€ dilate3x3.json              # Dilate algorithm config
â”‚   â””â”€â”€ gaussian5x5.json            # Gaussian algorithm config
â”œâ”€â”€ docs/
â”œâ”€â”€ scripts/
â”‚   â”œâ”€â”€ build.sh                    # Build script (--android, --lib, --clean options)
â”‚   â”œâ”€â”€ create_sdk.sh               # SDK packaging script
â”‚   â”œâ”€â”€ create_new_algo.sh          # Generate new algorithm template
â”‚   â”œâ”€â”€ generate_registry.sh        # Auto-generate algorithm registry
â”‚   â”œâ”€â”€ generate_test_image.py      # Test image generator
â”‚   â””â”€â”€ run.sh                      # Interactive run script
â”œâ”€â”€ lib/                            # ðŸ“¦ Release library directory
â”‚   â”œâ”€â”€ README.md                   # Library release documentation
â”‚   â””â”€â”€ libopencl_imgproc.a/.so     # Compiled library (for SDK distribution)
â”œâ”€â”€ include/                        # âœ… Public API (Stable Interface)
â”‚   â”œâ”€â”€ op_interface.h              # Algorithm interface
â”‚   â”œâ”€â”€ op_registry.h               # Registration macros
â”‚   â”œâ”€â”€ algorithm_runner.h          # Forward declarations
â”‚   â””â”€â”€ utils/                      # Public utilities
â”‚       â”œâ”€â”€ safe_ops.h              # Safe arithmetic operations
â”‚       â””â”€â”€ verify.h                # Verification functions
â”œâ”€â”€ examples/                       # ðŸ‘¤ User Algorithm Implementations
â”‚   â”œâ”€â”€ gaussian/
â”‚   â”‚   â”œâ”€â”€ c_ref/gaussian5x5_ref.c # CPU reference + registration
â”‚   â”‚   â””â”€â”€ cl/*.cl                 # GPU kernel variants
â”‚   â””â”€â”€ dilate/
â”‚       â”œâ”€â”€ c_ref/dilate3x3_ref.c   # CPU reference + registration
â”‚       â””â”€â”€ cl/*.cl                 # GPU kernel variants
â”œâ”€â”€ src/                            # ðŸ”’ Library Implementation (Internal)
â”‚   â”œâ”€â”€ core/                       # Business Logic
â”‚   â”‚   â”œâ”€â”€ algorithm_runner.c      # Execution pipeline
â”‚   â”‚   â”œâ”€â”€ android_runner.c        # Execution pipeline for android
â”‚   â”‚   â”œâ”€â”€ op_registry.c           # Algorithm registry
â”‚   â”‚   â””â”€â”€ auto_registry.c         # Auto-generated (don't edit)
â”‚   â”œâ”€â”€ platform/                   # OpenCL Abstraction
â”‚   â”‚   â”œâ”€â”€ opencl_utils.c/.h       # Platform initialization
â”‚   â”‚   â”œâ”€â”€ cache_manager.c/.h      # Binary & golden caching
â”‚   â”‚   â””â”€â”€ cl_extension_api.c/.h   # Custom host API
â”‚   â”œâ”€â”€ utils/                      # Infrastructure
â”‚   â”‚   â”œâ”€â”€ config.c/.h             # Configuration parser
â”‚   â”‚   â”œâ”€â”€ image_io.c/.h           # Image I/O
â”‚   â”‚   â””â”€â”€ verify.c                # Verification implementation
â”‚   â””â”€â”€ main.c                      # Application entry point
â””â”€â”€ test_data/
    â”œâ”€â”€ dilate3x3/
    â””â”€â”€ gaussian5x5/
```